// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'router_provider_information.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$RouterProviderInformation {
  List<String> get dontRequireLoginRouteLocations =>
      throw _privateConstructorUsedError;
  List<String> get requireLoginRouteLocations =>
      throw _privateConstructorUsedError;
  String get initialRouteLocation => throw _privateConstructorUsedError;
  String get signUpRouteLocation => throw _privateConstructorUsedError;
  String get signInRouteLocation => throw _privateConstructorUsedError;
  String get errorLoadingUserRouteLocation =>
      throw _privateConstructorUsedError;
  String get loadingUserRouteLocation => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RouterProviderInformationCopyWith<RouterProviderInformation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RouterProviderInformationCopyWith<$Res> {
  factory $RouterProviderInformationCopyWith(RouterProviderInformation value,
          $Res Function(RouterProviderInformation) then) =
      _$RouterProviderInformationCopyWithImpl<$Res, RouterProviderInformation>;
  @useResult
  $Res call(
      {List<String> dontRequireLoginRouteLocations,
      List<String> requireLoginRouteLocations,
      String initialRouteLocation,
      String signUpRouteLocation,
      String signInRouteLocation,
      String errorLoadingUserRouteLocation,
      String loadingUserRouteLocation});
}

/// @nodoc
class _$RouterProviderInformationCopyWithImpl<$Res,
        $Val extends RouterProviderInformation>
    implements $RouterProviderInformationCopyWith<$Res> {
  _$RouterProviderInformationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dontRequireLoginRouteLocations = null,
    Object? requireLoginRouteLocations = null,
    Object? initialRouteLocation = null,
    Object? signUpRouteLocation = null,
    Object? signInRouteLocation = null,
    Object? errorLoadingUserRouteLocation = null,
    Object? loadingUserRouteLocation = null,
  }) {
    return _then(_value.copyWith(
      dontRequireLoginRouteLocations: null == dontRequireLoginRouteLocations
          ? _value.dontRequireLoginRouteLocations
          : dontRequireLoginRouteLocations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      requireLoginRouteLocations: null == requireLoginRouteLocations
          ? _value.requireLoginRouteLocations
          : requireLoginRouteLocations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      initialRouteLocation: null == initialRouteLocation
          ? _value.initialRouteLocation
          : initialRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      signUpRouteLocation: null == signUpRouteLocation
          ? _value.signUpRouteLocation
          : signUpRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      signInRouteLocation: null == signInRouteLocation
          ? _value.signInRouteLocation
          : signInRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      errorLoadingUserRouteLocation: null == errorLoadingUserRouteLocation
          ? _value.errorLoadingUserRouteLocation
          : errorLoadingUserRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      loadingUserRouteLocation: null == loadingUserRouteLocation
          ? _value.loadingUserRouteLocation
          : loadingUserRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_RouterProviderInformationCopyWith<$Res>
    implements $RouterProviderInformationCopyWith<$Res> {
  factory _$$_RouterProviderInformationCopyWith(
          _$_RouterProviderInformation value,
          $Res Function(_$_RouterProviderInformation) then) =
      __$$_RouterProviderInformationCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<String> dontRequireLoginRouteLocations,
      List<String> requireLoginRouteLocations,
      String initialRouteLocation,
      String signUpRouteLocation,
      String signInRouteLocation,
      String errorLoadingUserRouteLocation,
      String loadingUserRouteLocation});
}

/// @nodoc
class __$$_RouterProviderInformationCopyWithImpl<$Res>
    extends _$RouterProviderInformationCopyWithImpl<$Res,
        _$_RouterProviderInformation>
    implements _$$_RouterProviderInformationCopyWith<$Res> {
  __$$_RouterProviderInformationCopyWithImpl(
      _$_RouterProviderInformation _value,
      $Res Function(_$_RouterProviderInformation) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dontRequireLoginRouteLocations = null,
    Object? requireLoginRouteLocations = null,
    Object? initialRouteLocation = null,
    Object? signUpRouteLocation = null,
    Object? signInRouteLocation = null,
    Object? errorLoadingUserRouteLocation = null,
    Object? loadingUserRouteLocation = null,
  }) {
    return _then(_$_RouterProviderInformation(
      dontRequireLoginRouteLocations: null == dontRequireLoginRouteLocations
          ? _value._dontRequireLoginRouteLocations
          : dontRequireLoginRouteLocations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      requireLoginRouteLocations: null == requireLoginRouteLocations
          ? _value._requireLoginRouteLocations
          : requireLoginRouteLocations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      initialRouteLocation: null == initialRouteLocation
          ? _value.initialRouteLocation
          : initialRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      signUpRouteLocation: null == signUpRouteLocation
          ? _value.signUpRouteLocation
          : signUpRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      signInRouteLocation: null == signInRouteLocation
          ? _value.signInRouteLocation
          : signInRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      errorLoadingUserRouteLocation: null == errorLoadingUserRouteLocation
          ? _value.errorLoadingUserRouteLocation
          : errorLoadingUserRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
      loadingUserRouteLocation: null == loadingUserRouteLocation
          ? _value.loadingUserRouteLocation
          : loadingUserRouteLocation // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_RouterProviderInformation implements _RouterProviderInformation {
  const _$_RouterProviderInformation(
      {required final List<String> dontRequireLoginRouteLocations,
      required final List<String> requireLoginRouteLocations,
      required this.initialRouteLocation,
      required this.signUpRouteLocation,
      required this.signInRouteLocation,
      required this.errorLoadingUserRouteLocation,
      required this.loadingUserRouteLocation})
      : _dontRequireLoginRouteLocations = dontRequireLoginRouteLocations,
        _requireLoginRouteLocations = requireLoginRouteLocations;

  final List<String> _dontRequireLoginRouteLocations;
  @override
  List<String> get dontRequireLoginRouteLocations {
    if (_dontRequireLoginRouteLocations is EqualUnmodifiableListView)
      return _dontRequireLoginRouteLocations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_dontRequireLoginRouteLocations);
  }

  final List<String> _requireLoginRouteLocations;
  @override
  List<String> get requireLoginRouteLocations {
    if (_requireLoginRouteLocations is EqualUnmodifiableListView)
      return _requireLoginRouteLocations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requireLoginRouteLocations);
  }

  @override
  final String initialRouteLocation;
  @override
  final String signUpRouteLocation;
  @override
  final String signInRouteLocation;
  @override
  final String errorLoadingUserRouteLocation;
  @override
  final String loadingUserRouteLocation;

  @override
  String toString() {
    return 'RouterProviderInformation(dontRequireLoginRouteLocations: $dontRequireLoginRouteLocations, requireLoginRouteLocations: $requireLoginRouteLocations, initialRouteLocation: $initialRouteLocation, signUpRouteLocation: $signUpRouteLocation, signInRouteLocation: $signInRouteLocation, errorLoadingUserRouteLocation: $errorLoadingUserRouteLocation, loadingUserRouteLocation: $loadingUserRouteLocation)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RouterProviderInformation &&
            const DeepCollectionEquality().equals(
                other._dontRequireLoginRouteLocations,
                _dontRequireLoginRouteLocations) &&
            const DeepCollectionEquality().equals(
                other._requireLoginRouteLocations,
                _requireLoginRouteLocations) &&
            (identical(other.initialRouteLocation, initialRouteLocation) ||
                other.initialRouteLocation == initialRouteLocation) &&
            (identical(other.signUpRouteLocation, signUpRouteLocation) ||
                other.signUpRouteLocation == signUpRouteLocation) &&
            (identical(other.signInRouteLocation, signInRouteLocation) ||
                other.signInRouteLocation == signInRouteLocation) &&
            (identical(other.errorLoadingUserRouteLocation,
                    errorLoadingUserRouteLocation) ||
                other.errorLoadingUserRouteLocation ==
                    errorLoadingUserRouteLocation) &&
            (identical(
                    other.loadingUserRouteLocation, loadingUserRouteLocation) ||
                other.loadingUserRouteLocation == loadingUserRouteLocation));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_dontRequireLoginRouteLocations),
      const DeepCollectionEquality().hash(_requireLoginRouteLocations),
      initialRouteLocation,
      signUpRouteLocation,
      signInRouteLocation,
      errorLoadingUserRouteLocation,
      loadingUserRouteLocation);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RouterProviderInformationCopyWith<_$_RouterProviderInformation>
      get copyWith => __$$_RouterProviderInformationCopyWithImpl<
          _$_RouterProviderInformation>(this, _$identity);
}

abstract class _RouterProviderInformation implements RouterProviderInformation {
  const factory _RouterProviderInformation(
          {required final List<String> dontRequireLoginRouteLocations,
          required final List<String> requireLoginRouteLocations,
          required final String initialRouteLocation,
          required final String signUpRouteLocation,
          required final String signInRouteLocation,
          required final String errorLoadingUserRouteLocation,
          required final String loadingUserRouteLocation}) =
      _$_RouterProviderInformation;

  @override
  List<String> get dontRequireLoginRouteLocations;
  @override
  List<String> get requireLoginRouteLocations;
  @override
  String get initialRouteLocation;
  @override
  String get signUpRouteLocation;
  @override
  String get signInRouteLocation;
  @override
  String get errorLoadingUserRouteLocation;
  @override
  String get loadingUserRouteLocation;
  @override
  @JsonKey(ignore: true)
  _$$_RouterProviderInformationCopyWith<_$_RouterProviderInformation>
      get copyWith => throw _privateConstructorUsedError;
}
